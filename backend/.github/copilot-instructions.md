# Copilot Instructions – Backend (FormFlow)

You are working inside the **backend** of the FormFlow project.

This backend is a **Node.js + TypeScript** API server using:

- **Express** for HTTP server and routing.
- **Drizzle ORM** for database interaction.
- **SQLite** as the database (using `libsql` driver).
- The frontend will consume these APIs via HTTP.

---

## Tech & Structure

- Language: **TypeScript**
- Runtime: **Node.js**
- Framework: **Express**
- ORM: **Drizzle ORM**
- Database: **SQLite** (via `@libsql/client`)

### Suggested Folder Structure

Use a clean structure like:

```txt
backend/
  drizzle/          # Migrations folder (generated by drizzle-kit)
  src/
    app.ts          # Express app setup
    server.ts       # Server listen logic
    config/
      env.ts        # Environment variables, config helpers
    db/
      index.ts      # Drizzle client instance (db connection)
      schema.ts     # Database schema definitions
    routes/
      auth.routes.ts
      index.ts      # attach all routers
    controllers/
      auth.controller.ts
    services/
      auth.service.ts
    middleware/
      errorHandler.ts
      authGuard.ts  # JWT-based auth if needed
    types/
      express.d.ts  # type augmentation if needed
  drizzle.config.ts # Drizzle Kit configuration
  package.json
  tsconfig.json
```

When generating code, keep responsibilities separated:

- **routes** → define endpoints and attach controllers.
- **controllers** → handle `req`/`res`, call services.
- **services** → contain business logic and interact with Drizzle.
- **db/index.ts** → export the `db` instance.
- **db/schema.ts** → define tables and relations.

---

## Database & Drizzle

- **Installation**:

  - `npm i drizzle-orm @libsql/client dotenv`
  - `npm i -D drizzle-kit`

- **Configuration** (`drizzle.config.ts`):

```ts
import "dotenv/config";
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./drizzle",
  schema: "./src/db/schema.ts",
  dialect: "sqlite",
  dbCredentials: {
    url: process.env.DB_FILE_NAME!, // e.g., "file:local.db"
  },
});
```

- **Connection** (`src/db/index.ts`):

```ts
import "dotenv/config";
import { drizzle } from "drizzle-orm/libsql";

export const db = drizzle(process.env.DB_FILE_NAME!);
```

- **Schema Definition** (`src/db/schema.ts`):
  Define a `users` table for authentication with at least:

```ts
import { int, sqliteTable, text } from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

export const usersTable = sqliteTable("users", {
  id: int().primaryKey({ autoIncrement: true }),
  email: text().notNull().unique(),
  passwordHash: text().notNull(),
  createdAt: int({ mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
  updatedAt: int({ mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
});
```

- **Migrations**:
  - Use `npx drizzle-kit push` for rapid local development.
  - Or `npx drizzle-kit generate` and `npx drizzle-kit migrate` for production-ready migrations.

---

## Authentication APIs

Implement basic **email/password** authentication with:

- `POST /api/auth/signup`

  - Accepts: `email`, `password`.
  - Validates input (non-empty, email format, password length).
  - Hashes password using `bcrypt` (or similar).
  - Stores user in DB if the email is not yet used.
  - Returns a success response (and optionally a JWT or session cookie).

- `POST /api/auth/login`

  - Accepts: `email`, `password`.
  - Validates input.
  - Checks credentials against stored user (`passwordHash`).
  - On success:
    - return a **JWT token** in JSON.
  - On failure:
    - return appropriate 401/400 error with JSON message.

- `POST /api/auth/logout`
  - For now, just return 200 with a JSON message like `{ success: true }`.
  - The frontend will handle forgetting the token; no server-side session store is needed.

Use proper status codes:

- `201` for successful signup.
- `200` for successful login/logout.
- `400` for validation errors.
- `401` for invalid credentials.
- `500` for unexpected server errors (log internally, return generic message).

---

## Middleware & Error Handling

- Create a **global error handler** middleware that:

  - logs the error (without leaking sensitive info),
  - returns a JSON error response with a consistent shape (e.g. `{ message, details? }`).

- If using JWT:
  - implement an `authGuard` middleware that:
    - reads the token from header or cookie,
    - verifies it,
    - attaches `req.user` with basic info,
    - calls `next()` or returns 401.

---

## General Guidelines

- Always use **TypeScript types** for:

  - request bodies,
  - responses,
  - service functions,
  - Drizzle schema types (use `$inferSelect` and `$inferInsert`).

- Don’t put Drizzle queries directly in route files; keep them in services.

- Favor async/await style and wrap route handlers to catch errors cleanly.

- Keep responses **JSON-only**, no HTML.

- Aim for clear, maintainable code that is easy for another developer to read and extend.
